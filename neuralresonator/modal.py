# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_modal.ipynb.

# %% auto 0
__all__ = ['default_material_ranges', 'MATERIALS', 'eigenvalue_to_frequency', 'frequency_to_eigenvalue', 'render_modes',
           'render_modes_coeffs', 'create_mesh', 'create_basis', 'scale', 'unscale', 'MaterialRanges', 'Material',
           'System']

# %% ../nbs/01_modal.ipynb 2
from enum import Enum
from functools import cache, cached_property
from typing import NamedTuple, Optional, Union

import numpy as np
from skfem import (
    asm,
    condense,
    Basis,
    BilinearForm,
    ElementTriP2,
    ElementVector,
    Mesh2D,
    MeshTri,
    solve,
    solver_eigen_scipy_sym,
)
from skfem.helpers import dot
from skfem.models.elasticity import linear_elasticity
import torch

# %% ../nbs/01_modal.ipynb 5
def eigenvalue_to_frequency(eigenvalues):
    return eigenvalues**0.5 / (2 * np.pi)


def frequency_to_eigenvalue(frequencies):
    return (frequencies * (2 * np.pi)) ** 2

# %% ../nbs/01_modal.ipynb 6
def render_modes(
    frequency: Union[torch.Tensor, np.ndarray],  # Mode frequencies
    decay: Union[torch.Tensor, np.ndarray],  # Mode decay parameters
    amplitude: Union[torch.Tensor, np.ndarray],  # Mode amplitudes
    initial_phase: Optional[
        Union[torch.Tensor, np.ndarray]
    ] = None,  # Mode initial phases
    length_in_samples: int = 44100,  # Length of the output signal in samples
    sample_rate: float = 44100,  # Sample rate of the output signal
    return_sum: bool = True,  # Return the sum of the modes
) -> Union[torch.Tensor, np.ndarray]:  # Rendered signal
    "Renders a batch of modes given their parameters."

    backend = torch if isinstance(frequency, torch.Tensor) else np

    initial_phase = (
        backend.zeros_like(frequency) if initial_phase is None else initial_phase
    )
    angular_frequency = 2 * np.pi * frequency
    time_axis = backend.arange(length_in_samples) / sample_rate
    envelope = backend.exp(-decay[..., None] * time_axis)
    sinusoids = backend.cos(
        angular_frequency[..., None] * time_axis + initial_phase[..., None]
    )
    signal = envelope * sinusoids * amplitude[..., None]
    return signal.sum(-2) if return_sum else signal


def render_modes_coeffs(
    eigenvalues: Union[np.ndarray, torch.Tensor],
    eigenvectors: Union[np.ndarray, torch.Tensor],
    alpha: float,
    beta: float,
    length_in_samples: int = 44100,
    sample_rate: int = 44100,
):
    """
    Renders a batch of modes given damping coefficients.
    """

    damping_coeffs = 0.5 * (alpha + beta * eigenvalues)
    damped_freqs = eigenvalues - damping_coeffs**2
    damped_freqs[damped_freqs < 0] = 0
    damped_freqs = eigenvalue_to_frequency(damped_freqs)
    modes = render_modes(
        damped_freqs,
        damping_coeffs,
        eigenvectors,
        length_in_samples=length_in_samples,
        sample_rate=sample_rate,
    )
    return modes

# %% ../nbs/01_modal.ipynb 12
def create_mesh(n_refinements: int = 5):
    "Initialise a triangular mesh with `n_refinements` refinements."
    return MeshTri().refined(n_refinements)


def create_basis(mesh: Mesh2D):
    "Construct a cell basis for the mesh."
    element = ElementTriP2()
    element_vector = ElementVector(element)
    return Basis(mesh, element_vector)

# %% ../nbs/01_modal.ipynb 13
def scale(value: float, range: tuple[float, float]) -> float:
    "Scale a value to a given range."
    return (value - range[0]) / (range[1] - range[0])


def unscale(value: float, range: tuple[float, float]) -> float:
    "Unscale a value from a given range."
    return value * (range[1] - range[0]) + range[0]


class MaterialRanges(NamedTuple):
    "Ranges for material properties."
    rho: tuple[float, float] = (500.0, 10000.0)  # material density
    E: tuple[float, float] = (1e9, 1e12)  # Young's modulus
    nu: tuple[float, float] = (0.0, 0.5)  # Poisson's number
    alpha: tuple[float, float] = (1.0, 30.0)  # Rayleigh damping coefficient $\alpha$
    beta: tuple[float, float] = (1e-8, 2e-6)  # Rayleigh damping coefficient $\beta$


default_material_ranges = MaterialRanges()


class Material(NamedTuple):
    "Material properties."
    rho: float  # material density
    E: float  # Young's modulus
    nu: float  # Poisson's number
    alpha: float  # Rayleigh damping coefficient $\alpha$
    beta: float  # Rayleigh damping coefficient $\beta$

    @classmethod
    def random(cls, generator: Optional[np.random.Generator] = None):
        "Create a random material."
        rnd = np.random.default_rng() if generator is None else generator
        return cls(
            rho=rnd.uniform(*default_material_ranges.rho),
            E=rnd.uniform(*default_material_ranges.E),
            nu=rnd.uniform(*default_material_ranges.nu),
            alpha=rnd.uniform(*default_material_ranges.alpha),
            beta=rnd.uniform(*default_material_ranges.beta),
        )

    @classmethod
    def set_default_ranges(cls, ranges: MaterialRanges):
        "Set the default ranges for material properties."
        global default_material_ranges
        default_material_ranges = ranges

    def scaled(self):
        "Scale material properties to the given range."
        return Material(
            **{
                k: scale(v, getattr(default_material_ranges, k))
                for k, v in self._asdict().items()
            }
        )

    def unscaled(self):
        "Unscale material properties from the given range."
        return Material(
            **{
                k: unscale(v, getattr(default_material_ranges, k))
                for k, v in self._asdict().items()
            }
        )


MATERIALS = dict(
    ceramic=Material(2700, 7.2e10, 0.19, 6, 1e-7),
    glass=Material(2600, 6.2e10, 0.20, 1, 1e-7),
    wood=Material(750, 1.0e10, 0.25, 60, 2e-6),
    plastic=Material(1070, 1.4e9, 0.35, 30, 1e-6),
    iron=Material(8000, 2.1e11, 0.28, 5, 1e-7),
    polycarbonate=Material(1190, 2.4e9, 0.37, 0.5, 4e-7),
    steel=Material(7850, 2.0e11, 0.29, 5, 3e-8),
    custom=Material(8000, 2.1e11, 0.49, 5, 1e-7),
)

# %% ../nbs/01_modal.ipynb 15
class System:
    """Defines an enumeration across materials, with vibrational modes given as a
    property of the material object."""

    def __init__(
        self,
        material: Material,  # material properties
        mesh: Optional[Mesh2D] = None,  # mesh
        basis: Optional[Basis] = None,  # basis
        k: int = 128,  # number of modes to compute
        force_cache: bool = False,  # force caching at init
    ):
        self.rho = material.rho
        self.E = material.E
        self.nu = material.nu
        self.alpha = material.alpha
        self.beta = material.beta
        self.mu = self.E / (2 * (1 + self.nu))
        self.lam = self.E * self.nu / ((1 + self.nu) * (1 - 2 * self.nu))
        self._mesh = mesh
        self._basis = basis
        self.k = k

        #! Force caching at init
        #! This should not be done, however it
        #! is unclear why pytorch_lighting reset the cache at each call
        if force_cache:
            self.modes

    def mass(self, u, v, *args):
        return self.rho * dot(u, v)

    @cached_property
    def mesh(self) -> Mesh2D:
        return create_mesh() if self._mesh is None else self._mesh

    @cached_property
    def basis(self) -> Basis:
        return create_basis(self.mesh) if self._basis is None else self._basis

    @cached_property
    def modes(self) -> tuple[np.ndarray, np.ndarray]:  # (eigenvalues, eigenvectors)
        "Construct and solve the eigenvalue problem for the material."
        # define bilinear form
        mass = BilinearForm(lambda *args: self.mass(*args))

        # assemble stiffness and mass matrices
        elasticity = linear_elasticity(self.lam, self.mu)
        K = asm(elasticity, self.basis)
        M = asm(mass, self.basis)

        # set boundary conditions
        D = self.basis.get_dofs()
        I = self.basis.complement_dofs(D)

        # solve the system
        eigenvalues, eigenvectors = solve(
            *condense(K, M, D=D), solver=solver_eigen_scipy_sym(k=self.k)
        )

        return eigenvalues, eigenvectors

    @cached_property
    def eigenvalues(self) -> np.ndarray:
        "Return the eigenvalues of the system."
        return self.modes[0]

    @cached_property
    def eigenvectors(self) -> np.ndarray:
        "Return the eigenvalues of the system."
        return self.modes[1]

    @cached_property
    def damping_coefficients(self) -> np.ndarray:
        "Computes modal damping coefficients for the material."
        return 0.5 * (self.alpha + self.beta * self.eigenvalues)

    @cached_property
    def damped_frequencies(self) -> np.ndarray:
        "Computes damped modal frequencies for the material."
        damped_frequencies = self.eigenvalues - self.damping_coefficients**2
        damped_frequencies[damped_frequencies < 0] = 0
        damped_frequencies = eigenvalue_to_frequency(damped_frequencies)
        return damped_frequencies

    @cache
    def get_mode_gains(
        self,
        node: Optional[int] = None,
    ) -> np.ndarray:
        "Computes mode gains for the material."

        # has shape [DOFs x nodes x modes]
        s = self.eigenvectors[self.basis.nodal_dofs]
        locs = self.basis.doflocs[:, self.basis.nodal_dofs[0, :].flatten()]

        # transpose to [nodes x modes x DOFs]
        mode_gains = np.transpose(s, (1, 2, 0))
        if node is not None:
            mode_gains = mode_gains[node]

        # normalize gains
        # direction = np.ones(2)
        # mode_gains = (mode_gains @ direction)

        mode_gains = np.sqrt(mode_gains[..., 0] ** 2 + mode_gains[..., 1] ** 2)

        return mode_gains

    def render(
        self,
        length_in_seconds: float,
        sample_rate: float = 44100,
        initial_phase: Optional[Union[torch.Tensor, np.ndarray]] = None,
        impulse_node_idx: int = 6,  # node to apply impulse to (default is 6 center node)
        truncate_modes: Optional[int] = None,  # truncate the number of modes to render
    ):
        "Render the modes of the material."
        length_in_samples = int(length_in_seconds * sample_rate)
        return render_modes(
            self.damped_frequencies[-truncate_modes:]
            if truncate_modes
            else self.damped_frequencies,
            self.damping_coefficients[-truncate_modes:]
            if truncate_modes
            else self.damping_coefficients,
            self.get_mode_gains(impulse_node_idx)[-truncate_modes:]
            if truncate_modes
            else self.get_mode_gains(impulse_node_idx),
            initial_phase,
            length_in_samples,
            sample_rate,
        )
